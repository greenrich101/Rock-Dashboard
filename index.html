<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Q1 2026 Company Scorecard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f7fa;
      color: #1a1a2e;
      line-height: 1.5;
    }

    /* Header */
    .header {
      background: linear-gradient(135deg, #1a1a2e, #2d2d44);
      color: white;
      padding: 24px 32px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 16px;
    }

    .header h1 { font-size: 24px; font-weight: 600; }
    .header-sub { font-size: 13px; opacity: 0.7; margin-top: 2px; }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* Market Toggle */
    .toggle-group {
      display: flex;
      background: rgba(255,255,255,0.12);
      border-radius: 8px;
      overflow: hidden;
    }

    .toggle-btn {
      padding: 8px 18px;
      font-size: 14px;
      font-weight: 500;
      border: none;
      background: transparent;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      transition: all 0.15s;
    }

    .toggle-btn.active {
      background: white;
      color: #1a1a2e;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    .refresh-btn {
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.25);
      background: transparent;
      color: white;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .refresh-btn:hover { background: rgba(255,255,255,0.1); }

    .refresh-btn.loading svg { animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .last-updated { font-size: 12px; opacity: 0.6; }

    /* Main */
    .main { max-width: 1400px; margin: 0 auto; padding: 24px; }

    /* KPI Cards */
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .kpi-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .kpi-label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #6b7280;
      margin-bottom: 8px;
    }

    .kpi-value {
      font-size: 32px;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin-bottom: 4px;
    }

    .kpi-forecast {
      font-size: 13px;
      color: #6b7280;
      margin-bottom: 12px;
    }

    .kpi-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 20px;
    }

    .kpi-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .status-green .kpi-dot { background: #059669; }
    .status-green { background: #d1fae5; color: #059669; }
    .status-yellow .kpi-dot { background: #d97706; }
    .status-yellow { background: #fef3c7; color: #d97706; }
    .status-red .kpi-dot { background: #dc2626; }
    .status-red { background: #fee2e2; color: #dc2626; }

    .rca-flag {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      color: #dc2626;
      margin-top: 8px;
    }

    /* Charts */
    .charts-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 24px;
    }

    @media (max-width: 768px) {
      .charts-grid { grid-template-columns: 1fr; }
    }

    .chart-card {
      background: white;
      border-radius: 12px;
      padding: 24px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    }

    .chart-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
    }

    .chart-container {
      position: relative;
      height: 280px;
    }

    /* Inventory Banner */
    .inventory-card {
      background: white;
      border-radius: 12px;
      padding: 20px 24px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      margin-bottom: 24px;
      display: flex;
      gap: 32px;
      align-items: center;
      flex-wrap: wrap;
    }

    .inv-title {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #6b7280;
    }

    .inv-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .inv-name { font-size: 14px; color: #6b7280; }

    .inv-num {
      font-size: 24px;
      font-weight: 700;
    }

    .inv-target {
      font-size: 12px;
      color: #6b7280;
    }

    /* Data Table */
    .table-card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      overflow: hidden;
      margin-bottom: 24px;
    }

    .table-header {
      padding: 20px 24px 12px;
      font-size: 16px;
      font-weight: 600;
    }

    .table-wrapper {
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    thead th {
      text-align: left;
      padding: 10px 14px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #6b7280;
      border-bottom: 2px solid #e5e7eb;
      white-space: nowrap;
    }

    tbody td {
      padding: 10px 14px;
      border-bottom: 1px solid #d1d5db;
      white-space: nowrap;
    }

    tbody tr:hover { background: #f9fafb; }

    .metric-group-label {
      font-weight: 600;
      color: #1a1a2e;
    }

    .row-type {
      color: #6b7280;
      font-size: 12px;
    }

    .cell-green { background: #d1fae5; color: #059669; border-radius: 4px; font-weight: 600; }
    .cell-yellow { background: #fef3c7; color: #d97706; border-radius: 4px; font-weight: 600; }
    .cell-red { background: #fee2e2; color: #dc2626; border-radius: 4px; font-weight: 600; }

    /* Legend */
    .legend {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: #6b7280;
      margin-bottom: 24px;
    }

    .legend-item { display: flex; align-items: center; gap: 5px; }
    .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

    /* Loading */
    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 50vh;
      gap: 16px;
    }

    .spinner {
      width: 32px; height: 32px;
      border: 3px solid #e5e7eb;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .loading-text { color: #6b7280; font-size: 14px; }

    .error-screen { text-align: center; padding: 60px 20px; }
    .error-screen h2 { font-size: 18px; margin-bottom: 8px; }
    .error-screen p { color: #6b7280; font-size: 14px; }

    /* Bottom Navigation */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #1a1a2e;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 24px;
      box-shadow: 0 -2px 8px rgba(0,0,0,0.15);
      z-index: 100;
      overflow-x: auto;
    }

    .nav-btn {
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 500;
      border: none;
      background: transparent;
      color: rgba(255,255,255,0.6);
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.15s;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .nav-btn:hover { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); }
    .nav-btn.active { background: white; color: #1a1a2e; font-weight: 600; }

    .main { padding-bottom: 72px; }

    /* Department badge */
    .dept-badge {
      display: inline-block;
      font-size: 11px;
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 4px;
      background: #e0e7ff;
      color: #3730a3;
      margin-right: 8px;
      vertical-align: middle;
    }

    /* Section color coding */
    .section-inventory .table-header { color: #0369a1; border-left: 4px solid #0ea5e9; padding-left: 20px; }
    .section-inventory thead th { background: #f0f9ff; }
    .section-customer-service .table-header { color: #7c3aed; border-left: 4px solid #8b5cf6; padding-left: 20px; }
    .section-customer-service thead th { background: #f5f3ff; }
    .section-technology .table-header { color: #b45309; border-left: 4px solid #f59e0b; padding-left: 20px; }
    .section-technology thead th { background: #fffbeb; }
    .section-finance .table-header { color: #047857; border-left: 4px solid #10b981; padding-left: 20px; }
    .section-finance thead th { background: #ecfdf5; }
    .section-performance .table-header { color: #1e40af; border-left: 4px solid #3b82f6; padding-left: 20px; }
    .section-performance thead th { background: #eff6ff; }

    /* Rocks section */
    .section-rocks .table-header { color: #9333ea; border-left: 4px solid #a855f7; padding-left: 20px; }
    .section-rocks thead th { background: #faf5ff; }

    .rocks-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .rock-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      border-left: 4px solid #e5e7eb;
    }

    .rock-card.rock-on-track { border-left-color: #059669; }
    .rock-card.rock-at-risk { border-left-color: #d97706; }
    .rock-card.rock-off-track { border-left-color: #dc2626; }

    .rock-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .rock-description {
      font-size: 13px;
      color: #4b5563;
      margin-bottom: 12px;
      line-height: 1.4;
    }

    .milestone-bar {
      display: flex;
      gap: 3px;
      margin-bottom: 6px;
    }

    .milestone-segment {
      flex: 1;
      height: 8px;
      border-radius: 4px;
      background: #e5e7eb;
    }

    .milestone-segment.ms-completed { background: #059669; }
    .milestone-segment.ms-behind { background: #fbbf24; }

    .milestone-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: #9ca3af;
    }

    .rock-pva {
      margin-top: 8px;
      font-size: 13px;
      font-weight: 600;
    }

    /* Password Modal */
    .pw-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }

    .pw-modal {
      background: #1a1a2e;
      color: white;
      border-radius: 12px;
      padding: 32px;
      width: 320px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .pw-modal h3 {
      font-size: 18px;
      margin-bottom: 16px;
    }

    .pw-modal input {
      width: 100%;
      padding: 10px 14px;
      font-size: 14px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(255,255,255,0.1);
      color: white;
      outline: none;
      margin-bottom: 12px;
    }

    .pw-modal input::placeholder { color: rgba(255,255,255,0.4); }
    .pw-modal input:focus { border-color: rgba(255,255,255,0.5); }

    .pw-modal button {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      background: white;
      color: #1a1a2e;
      cursor: pointer;
    }

    .pw-modal button:hover { opacity: 0.9; }

    .pw-error {
      color: #f87171;
      font-size: 13px;
      margin-top: 8px;
      display: none;
    }
  </style>
</head>
<body>

  <div class="header">
    <div>
      <h1>Q1 2026 Company Scorecard</h1>
      <div class="header-sub" id="lastUpdated"></div>
    </div>
    <div class="header-controls">
      <div class="toggle-group">
        <button class="toggle-btn active" data-market="us" onclick="setMarket('us')">ðŸ‡ºðŸ‡¸ US</button>
        <button class="toggle-btn" data-market="ca" onclick="setMarket('ca')">ðŸ‡¨ðŸ‡¦ Canada</button>
      </div>
      <button class="refresh-btn" onclick="loadData()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
        Refresh
      </button>
    </div>
  </div>

  <div class="main">
    <div id="app">
      <div class="loading-screen">
        <div class="spinner"></div>
        <div class="loading-text">Loading scorecard...</div>
      </div>
    </div>
  </div>

  <nav class="bottom-nav">
    <button class="nav-btn active" data-tab="company" onclick="switchTab('company')">Company Scorecard</button>
    <button class="nav-btn" data-tab="department" onclick="switchTab('department')">Department Scorecard</button>
    <button class="nav-btn" data-tab="rocks" onclick="switchTab('rocks')">Rocks</button>
  </nav>

  <div class="pw-overlay" id="pwOverlay" style="display:none;">
    <div class="pw-modal">
      <h3>Enter Password</h3>
      <input type="password" id="pwInput" placeholder="Password" onkeydown="if(event.key==='Enter')checkRocksPassword()">
      <button onclick="checkRocksPassword()">Unlock</button>
      <div class="pw-error" id="pwError">Incorrect password</div>
    </div>
  </div>

<script>
const SHEET_ID = '1qhaLjXublAWS4Zj2Tm7OK3jAdlTK4bW87q4TsoPPLog';
const SHEET_NAME = 'Company Scard';
const CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(SHEET_NAME)}`;

let allMetrics = [];
let inventoryMetrics = [];
let weekLabels = [];
let currentMarket = 'us';
let barChart = null;
let lineChart = null;

// --- CSV Parser ---
function parseCSV(text) {
  const rows = [];
  let current = '';
  let inQuotes = false;
  let row = [];
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (ch === '"') {
      if (inQuotes && text[i + 1] === '"') { current += '"'; i++; }
      else inQuotes = !inQuotes;
    } else if (ch === ',' && !inQuotes) {
      row.push(current); current = '';
    } else if ((ch === '\n' || ch === '\r') && !inQuotes) {
      if (ch === '\r' && text[i + 1] === '\n') i++;
      row.push(current); rows.push(row); row = []; current = '';
    } else {
      current += ch;
    }
  }
  if (current || row.length) { row.push(current); rows.push(row); }
  return rows;
}

function cleanNum(val) {
  if (!val || typeof val !== 'string') return null;
  const s = val.trim().replace(/[$,\s]/g, '').replace(/%$/, '');
  if (s === '' || s === 'â€”' || s === '-') return null;
  const n = parseFloat(s);
  return isNaN(n) ? null : n;
}

function getStatusClass(pct, isLowerBetter) {
  if (pct === null || pct === undefined) return '';
  if (isLowerBetter) {
    // Cost metrics: at/under plan = green, slightly over = yellow, way over = red
    if (pct <= 100) return 'green';
    if (pct <= 115) return 'yellow';
    return 'red';
  }
  if (pct >= 95) return 'green';
  if (pct >= 85) return 'yellow';
  return 'red';
}

// --- Metric name cleanup ---
const METRIC_NAMES = {
  'net sales': 'Total Net Sales',
  '1st order cm': '1st Order CM (Contribution Margin)',
  '1st order count': '1st Order Count',
  'repeat cm$': 'Repeat CM (Contribution Margin)',
  'repeat cm': 'Repeat CM (Contribution Margin)',
  'total cm $': 'Total CM (Contribution Margin)',
  'total cm': 'Total CM (Contribution Margin)',
};

function cleanMetricName(raw) {
  const lower = raw.toLowerCase();
  for (const [key, label] of Object.entries(METRIC_NAMES)) {
    if (lower.includes(key)) return label;
  }
  return raw.replace(/fcast|forecast|\(1000s\)|ðŸ‡ºðŸ‡²|ðŸ‡¨ðŸ‡¦/gi, '').replace(/\s+/g, ' ').trim();
}

// --- Data Extraction ---
function extractData(rows) {
  if (rows.length < 3) return;

  // Row 0 has dates, Row 1 has "WK 1", "WK 2" etc.
  const weekRow = rows[1];
  weekLabels = [];
  const dataCols = [];
  for (let j = 2; j <= 15 && j < weekRow.length; j++) {
    const val = (weekRow[j] || '').trim();
    if (val.match(/^WK\s*\d+/i)) {
      weekLabels.push(val);
      dataCols.push(j);
    }
  }

  // Total column = 16 (index 16)
  const totalCol = 16;
  const rcaCol = 17;

  allMetrics = [];
  inventoryMetrics = [];

  const dataRows = rows.slice(2); // skip header rows

  for (let i = 0; i < dataRows.length; i++) {
    const row = dataRows[i];
    if (!row || row.length < 3) continue;

    const col0 = (row[0] || '').trim();
    const col1 = (row[1] || '').trim();
    const col1Lower = col1.toLowerCase().replace(/\s+/g, ' ');

    // Detect Forecast rows
    if (col1Lower.includes('fcast') || col1Lower.includes('forecast')) {
      const dept = col0 || '';
      const isCA = col1.includes('ðŸ‡¨ðŸ‡¦') || col1Lower.includes('cad');
      const region = isCA ? 'ca' : 'us';
      const name = cleanMetricName(col1);
      const isCount = col1Lower.includes('count');

      // Forecast weekly values
      const forecastWeekly = dataCols.map(c => cleanNum(row[c]));
      const forecastTotal = cleanNum(row[totalCol]);

      // Actuals (next row)
      const actualsRow = dataRows[i + 1];
      let actualWeekly = dataCols.map(() => null);
      let actualTotal = null;
      if (actualsRow) {
        actualWeekly = dataCols.map(c => cleanNum(actualsRow[c]));
        actualTotal = cleanNum(actualsRow[totalCol]);
      }

      // Plan vs Actual (row after actuals)
      const pvaRow = dataRows[i + 2];
      let pvaWeekly = dataCols.map(() => null);
      let pvaTotal = null;
      let hasRCA = false;
      if (pvaRow && (pvaRow[1] || '').toLowerCase().includes('plan vs actual')) {
        pvaWeekly = dataCols.map(c => cleanNum(pvaRow[c]));
        pvaTotal = cleanNum(pvaRow[totalCol]);
        hasRCA = ((pvaRow[rcaCol] || '') + (pvaRow[totalCol + 1] || '')).toLowerCase().includes('rca');
      }

      // Find latest week with actual data
      let latestWeekIdx = -1;
      for (let k = actualWeekly.length - 1; k >= 0; k--) {
        if (actualWeekly[k] !== null) { latestWeekIdx = k; break; }
      }

      allMetrics.push({
        dept, name, region, isCount,
        forecastWeekly, forecastTotal,
        actualWeekly, actualTotal,
        pvaWeekly, pvaTotal,
        hasRCA, latestWeekIdx,
      });

      i += 2; // skip actuals + pva rows
      continue;
    }

    // Detect inventory rows
    if (col1Lower.includes('days') && col1Lower.includes('target')) {
      const targetMatch = col1.match(/target\s*(\d+)/i);
      const target = targetMatch ? parseInt(targetMatch[1]) : null;
      const productName = col1.replace(/ðŸ‡ºðŸ‡²|ðŸ‡¨ðŸ‡¦/g, '').replace(/target\s*\d+\s*days?/i, '').trim();
      const vals = dataCols.map(c => cleanNum(row[c]));
      let latest = null;
      for (let k = vals.length - 1; k >= 0; k--) {
        if (vals[k] !== null) { latest = vals[k]; break; }
      }
      inventoryMetrics.push({ name: productName, target, latest, vals });
    }
  }
}

function shortName(name) {
  return name.replace(/\s*\(Contribution Margin\)/g, '');
}

// --- Format helpers ---
function fmtCurrency(n, isCount) {
  if (n === null || n === undefined) return 'â€”';
  if (isCount) return Math.round(n).toLocaleString();
  const abs = Math.abs(n);
  const sign = n < 0 ? '-' : '';
  return sign + '$' + abs.toFixed(abs >= 100 ? 0 : 1) + 'K';
}

function fmtPct(n) {
  if (n === null || n === undefined) return 'â€”';
  return Math.round(n) + '%';
}

// --- Render ---
function render() {
  const filtered = allMetrics.filter(m => m.region === currentMarket);
  if (filtered.length === 0 && inventoryMetrics.length === 0) {
    document.getElementById('app').innerHTML = `
      <div class="error-screen">
        <h2>No data for this market</h2>
        <p>Try switching to the other market toggle.</p>
      </div>`;
    return;
  }

  let html = '';

  // Legend
  html += `<div class="legend">
    <span class="legend-item"><span class="legend-dot" style="background:#059669"></span> â‰¥ 95%</span>
    <span class="legend-item"><span class="legend-dot" style="background:#d97706"></span> 85â€“94%</span>
    <span class="legend-item"><span class="legend-dot" style="background:#dc2626"></span> &lt; 85%</span>
  </div>`;

  // KPI Cards â€” sort: AOV first, CAC second, Meta CTR third, rest after
  const kpiOrder = ['aov', 'cac', 'ctr'];
  const sortedFiltered = [...filtered].sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    let aIdx = kpiOrder.findIndex(k => aName.includes(k));
    let bIdx = kpiOrder.findIndex(k => bName.includes(k));
    if (aIdx === -1) aIdx = kpiOrder.length;
    if (bIdx === -1) bIdx = kpiOrder.length;
    return aIdx - bIdx;
  });

  html += '<div class="kpi-grid">';
  sortedFiltered.forEach(m => {
    const status = getStatusClass(m.pvaTotal);
    const val = m.actualTotal !== null ? fmtCurrency(m.actualTotal, m.isCount) : 'â€”';
    const fcast = m.forecastTotal !== null ? fmtCurrency(m.forecastTotal, m.isCount) : 'â€”';
    html += `
      <div class="kpi-card">
        <div class="kpi-label">${m.dept ? `<span class="dept-badge">${m.dept}</span>` : ''}${m.name}</div>
        <div class="kpi-value">${val}</div>
        <div class="kpi-forecast">of ${fcast} forecast</div>
        <span class="kpi-badge status-${status}">
          <span class="kpi-dot"></span>
          ${fmtPct(m.pvaTotal)} of plan
        </span>
        ${m.hasRCA ? '<div class="rca-flag">âš  RCA Required</div>' : ''}
      </div>`;
  });
  html += '</div>';

  // Find CAC metric for bar chart
  const cacMetric = filtered.find(m => m.name.toLowerCase().includes('cac')) || filtered[0];

  // Charts
  html += `<div class="charts-grid">
    <div class="chart-card">
      <div class="chart-title">${cacMetric ? shortName(cacMetric.name) : 'Metric'} â€” Plan vs Actual</div>
      <div class="chart-container"><canvas id="barChart"></canvas></div>
    </div>
    <div class="chart-card">
      <div class="chart-title">Weekly Performance (95% Of Target)</div>
      <div class="chart-container"><canvas id="lineChart"></canvas></div>
      <div style="margin-top:6px;font-size:10px;color:#9ca3af;">* 1st order contribution margin goal is always relative to new customer number</div>
    </div>
  </div>`;

  // Inventory
  if (inventoryMetrics.length > 0) {
    html += '<div class="inventory-card"><div class="inv-title">Inventory Days</div>';
    inventoryMetrics.forEach(m => {
      const color = (m.latest !== null && m.target && m.latest >= m.target) ? '#059669' : '#dc2626';
      html += `
        <div class="inv-item">
          <span class="inv-name">${m.name}</span>
          <span class="inv-num" style="color:${color}">${m.latest !== null ? Math.round(m.latest) : 'â€”'}</span>
          <span class="inv-target">target ${m.target} days</span>
        </div>`;
    });
    html += '</div>';
  }

  // Data Table
  html += `<div class="table-card">
    <div class="table-header">Weekly Breakdown</div>
    <div class="table-wrapper"><table>
      <thead><tr>
        <th>Metric</th><th>Type</th>`;
  weekLabels.forEach(w => { html += `<th>${w}</th>`; });
  html += `<th>Total</th></tr></thead><tbody>`;

  filtered.forEach(m => {
    // Forecast row
    html += `<tr>
      <td class="metric-group-label" rowspan="3">${shortName(m.name)}</td>
      <td class="row-type">Forecast</td>`;
    m.forecastWeekly.forEach(v => {
      html += `<td>${v !== null ? (m.isCount ? Math.round(v) : '$' + v) : ''}</td>`;
    });
    html += `<td><strong>${m.forecastTotal !== null ? fmtCurrency(m.forecastTotal, m.isCount) : ''}</strong></td></tr>`;

    // Actuals row
    html += `<tr><td class="row-type">Actual</td>`;
    m.actualWeekly.forEach(v => {
      html += `<td>${v !== null ? (m.isCount ? Math.round(v) : '$' + v) : ''}</td>`;
    });
    html += `<td><strong>${m.actualTotal !== null ? fmtCurrency(m.actualTotal, m.isCount) : ''}</strong></td></tr>`;

    // PvA row
    html += `<tr><td class="row-type">% of Plan</td>`;
    m.pvaWeekly.forEach(v => {
      const cls = v !== null && v !== 0 ? 'cell-' + getStatusClass(v) : '';
      html += `<td class="${cls}">${v !== null && v !== 0 ? fmtPct(v) : ''}</td>`;
    });
    const totalCls = m.pvaTotal !== null ? 'cell-' + getStatusClass(m.pvaTotal) : '';
    html += `<td class="${totalCls}"><strong>${fmtPct(m.pvaTotal)}</strong></td></tr>`;
  });

  html += '</tbody></table></div></div>';

  document.getElementById('app').innerHTML = html;

  // Draw charts
  drawBarChart(cacMetric);
  drawLineChart(filtered);
}

// --- Charts ---
const METRIC_COLORS = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981'];

function drawBarChart(metric) {
  if (!metric) return;
  const ctx = document.getElementById('barChart');
  if (!ctx) return;
  if (barChart) barChart.destroy();

  const labels = weekLabels.slice(0, metric.forecastWeekly.length);

  barChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'Plan',
          data: metric.forecastWeekly.map(v => v !== null ? Math.abs(v) : null),
          backgroundColor: '#94a3b8',
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.7,
        },
        {
          label: 'Actual',
          data: metric.actualWeekly.map(v => v !== null ? Math.abs(v) : null),
          backgroundColor: '#3b82f6',
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.7,
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 16, font: { size: 12 } } },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const v = ctx.parsed.y;
              return ctx.dataset.label + ': ' + (metric.isCount ? v : '$' + v + 'K');
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          grid: { color: '#f3f4f6' },
          ticks: { font: { size: 11 }, callback: v => metric.isCount ? v : '$' + v + 'K' }
        },
        x: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

function drawLineChart(metrics) {
  const ctx = document.getElementById('lineChart');
  if (!ctx) return;
  if (lineChart) lineChart.destroy();

  const datasets = metrics.map((m, i) => ({
    label: shortName(m.name),
    data: m.pvaWeekly.map(v => (v !== null && v !== 0) ? v : null),
    borderColor: METRIC_COLORS[i % METRIC_COLORS.length],
    backgroundColor: 'transparent',
    borderWidth: 2.5,
    pointRadius: 3,
    pointHoverRadius: 5,
    tension: 0.3,
    spanGaps: false,
  }));

  // 95% target line
  datasets.push({
    label: '95% Target',
    data: weekLabels.map(() => 95),
    borderColor: '#dc2626',
    borderDash: [6, 4],
    borderWidth: 1.5,
    pointRadius: 0,
    pointHoverRadius: 0,
  });

  lineChart = new Chart(ctx, {
    type: 'line',
    data: { labels: weekLabels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 12, font: { size: 11 } } },
        tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + (ctx.parsed.y !== null ? ctx.parsed.y + '%' : 'â€”') } }
      },
      scales: {
        y: {
          min: 0,
          max: 250,
          grid: { color: '#f3f4f6' },
          ticks: { font: { size: 11 }, callback: v => v + '%' }
        },
        x: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

// --- Market toggle ---
function setMarket(market) {
  currentMarket = market;
  document.querySelectorAll('.toggle-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.market === market);
  });
  render();
}

// --- Load ---
async function loadData() {
  const btn = document.querySelector('.refresh-btn');
  if (btn) btn.classList.add('loading');

  try {
    const res = await fetch(CSV_URL);
    if (!res.ok) throw new Error('Failed to fetch sheet');
    const text = await res.text();
    const rows = parseCSV(text);
    extractData(rows);

    if (allMetrics.length === 0) {
      document.getElementById('app').innerHTML = `
        <div class="error-screen">
          <h2>No metrics found</h2>
          <p>Could not parse data from the spreadsheet.</p>
        </div>`;
      return;
    }

    render();

    const now = new Date();
    document.getElementById('lastUpdated').textContent =
      'Updated ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } catch (err) {
    document.getElementById('app').innerHTML = `
      <div class="error-screen">
        <h2>Couldn't load data</h2>
        <p>Make sure the Google Sheet is shared as "Anyone with the link."</p>
        <p style="margin-top:8px;font-size:12px;color:#6b7280;">${err.message}</p>
      </div>`;
  } finally {
    if (btn) btn.classList.remove('loading');
  }
}

// --- Department Scorecard ---
const DEPT_SHEET_NAME = 'Dept S.cards';
const DEPT_CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(DEPT_SHEET_NAME)}`;

let deptSections = [];
let deptWeekLabels = [];
let deptBarChart = null;
let deptLineChart = null;
let currentTab = 'company';

// --- Rocks ---
const ROCKS_CSV_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=1771278634`;
let rocksData = [];
let rockWeekLabels = [];
let rockMilestoneDescriptions = {};
let rockBarChart = null;
let rockLineChart = null;

// Section headers in the sheet
const SECTION_HEADERS = ['inventory', 'customer service', 'technology', 'finance'];

function extractDeptData(rows) {
  if (rows.length < 3) return;

  const weekRow = rows[1];
  deptWeekLabels = [];
  const dataCols = [];
  for (let j = 2; j <= 15 && j < weekRow.length; j++) {
    const val = (weekRow[j] || '').trim();
    if (val.match(/^WK\s*\d+/i)) {
      deptWeekLabels.push(val);
      dataCols.push(j);
    }
  }

  deptSections = [];
  let currentSection = { title: 'Performance', metrics: [] };
  deptSections.push(currentSection);

  const dataRows = rows.slice(2);

  for (let i = 0; i < dataRows.length; i++) {
    const row = dataRows[i];
    if (!row || row.length < 2) continue;

    const col0 = (row[0] || '').trim();
    const col1 = (row[1] || '').trim();
    const col1Lower = col1.toLowerCase().trim();

    // Skip empty rows
    if (!col0 && !col1) continue;

    // Detect section headers (col0 has a value, col1 is empty)
    if (col0 && !col1) {
      const lowerCol0 = col0.toLowerCase();
      if (SECTION_HEADERS.some(s => lowerCol0.includes(s))) {
        currentSection = { title: col0, metrics: [] };
        deptSections.push(currentSection);
        continue;
      }
    }

    // Detect triplet: Forecast row followed by Actuals + Plan vs Actual
    const nextRow = dataRows[i + 1];
    const pvaRow = dataRows[i + 2];
    const hasActuals = nextRow && (nextRow[1] || '').toLowerCase().includes('actual');
    const hasPva = pvaRow && (pvaRow[1] || '').toLowerCase().includes('plan vs actual');

    if (col1 && hasActuals && hasPva) {
      // This is a forecast/actual/pva triplet
      const dept = col0 || (nextRow[0] || '').trim() || (pvaRow[0] || '').trim();
      const flag = col1.includes('ðŸ‡¨ðŸ‡¦') ? 'ðŸ‡¨ðŸ‡¦' : col1.includes('ðŸŒ') ? 'ðŸŒ' : 'ðŸ‡ºðŸ‡¸';
      const name = col1.replace(/fcast|forecast/gi, '').replace(/ðŸŒ|ðŸ‡ºðŸ‡²|ðŸ‡¨ðŸ‡¦/g, '').trim();
      const weekly = dataCols.map(c => cleanNum(row[c]));
      const actualWeekly = dataCols.map(c => cleanNum(nextRow[c]));
      const pvaWeekly = dataCols.map(c => cleanNum(pvaRow[c]));

      // Total col (col index 16 or first non-empty after week cols)
      let forecastTotal = null, actualTotal = null, pvaTotal = null;
      for (let t = dataCols[dataCols.length - 1] + 1; t < row.length && t <= 17; t++) {
        const v = cleanNum(row[t]);
        if (v !== null) { forecastTotal = v; break; }
      }
      for (let t = dataCols[dataCols.length - 1] + 1; t < nextRow.length && t <= 17; t++) {
        const v = cleanNum(nextRow[t]);
        if (v !== null) { actualTotal = v; break; }
      }
      for (let t = dataCols[dataCols.length - 1] + 1; t < pvaRow.length && t <= 17; t++) {
        const v = cleanNum(pvaRow[t]);
        if (v !== null) { pvaTotal = v; break; }
      }

      // Detect if values are currency (raw cell starts with $ or name contains USD/CAD/$)
      const rawFirstVal = (row[dataCols[0]] || '').trim();
      const isCurrency = rawFirstVal.startsWith('$') || /usd|cad|\$/i.test(col1);

      // Cost metrics where going over plan is bad
      const nameLower = col1.toLowerCase();
      const isLowerBetter = /cac|cost/i.test(nameLower);

      currentSection.metrics.push({
        type: 'triplet',
        dept, name, flag, isCurrency, isLowerBetter,
        forecastWeekly: weekly, forecastTotal,
        actualWeekly, actualTotal,
        pvaWeekly, pvaTotal,
      });

      i += 2; // skip actuals + pva rows
      continue;
    }

    // Standalone metric row (has dept code and values)
    if (col0 && col1) {
      const dept = col0;
      const flag = col1.includes('ðŸ‡¨ðŸ‡¦') ? 'ðŸ‡¨ðŸ‡¦' : col1.includes('ðŸŒ') ? 'ðŸŒ' : 'ðŸ‡ºðŸ‡¸';
      const name = col1.replace(/ðŸŒ|ðŸ‡ºðŸ‡²|ðŸ‡¨ðŸ‡¦/g, '').trim();
      const weekly = dataCols.map(c => cleanNum(row[c]));

      let total = null;
      for (let t = dataCols[dataCols.length - 1] + 1; t < row.length && t <= 17; t++) {
        const v = cleanNum(row[t]);
        if (v !== null) { total = v; break; }
      }

      // Determine if it has a target embedded in the name
      const targetMatch = col1.match(/(\d+[\.]?\d*)\s*(%|min|s\b|\/|<)/i);
      const { target: parsedTarget, isLowerBetter } = extractTarget(col1);

      currentSection.metrics.push({
        type: 'standalone',
        dept, name, flag, weekly, total,
        targetMatch: targetMatch ? targetMatch[0] : null,
        parsedTarget,
        isLowerBetter,
      });
      continue;
    }
  }

  // Remove empty sections
  deptSections = deptSections.filter(s => s.metrics.length > 0);
}

// --- Target extraction from metric names ---
function extractTarget(metricName) {
  const name = metricName;
  const nameLower = name.toLowerCase();
  let target = null;
  let isLowerBetter = false;

  // Pattern: $XX.XX (dollar amount targets â€” cost, lower is better)
  const dollarMatch = name.match(/\$\s*(\d+\.?\d*)/);
  if (dollarMatch) {
    target = parseFloat(dollarMatch[1]);
    isLowerBetter = true;
  }

  // Pattern: XX% (percentage targets â€” rates, higher is better)
  if (target === null) {
    const pctMatch = name.match(/(\d+\.?\d*)\s*%/);
    if (pctMatch) {
      target = parseFloat(pctMatch[1]);
      isLowerBetter = false;
    }
  }

  // Pattern: (XXK) â€” parenthesized K-suffixed targets like (30K), (50K)
  if (target === null) {
    const kParenMatch = name.match(/\((\d+\.?\d*)\s*K\)/i);
    if (kParenMatch && kParenMatch[1] !== '1000') {
      target = parseFloat(kParenMatch[1]);
      isLowerBetter = false; // Volume/list targets: higher is better
    }
  }

  // Pattern: <XX or â‰¤XX (explicit less-than targets)
  const ltMatch = name.match(/[<â‰¤]\s*(\d+\.?\d*)/);
  if (ltMatch) {
    target = parseFloat(ltMatch[1]);
    isLowerBetter = true;
  }

  // Pattern: XXmin, XXs, XXhrs (time targets â€” lower is better)
  if (target === null) {
    const timeMatch = name.match(/(\d+\.?\d*)\s*(min|mins|minutes|s|sec|seconds|hrs|hours)/i);
    if (timeMatch) {
      target = parseFloat(timeMatch[1]);
      isLowerBetter = true;
    }
  }

  // Fallback: general number before /, min, s, etc.
  if (target === null) {
    const numMatch = name.match(/(\d+\.?\d*)\s*(%|min|s\b|\/|<)/i);
    if (numMatch) {
      target = parseFloat(numMatch[1]);
    }
  }

  // Keyword overrides for directionality
  const lowerKeywords = ['ship', 'cost', 'cac', 'time', 'response', 'wait', 'delay', 'abandon', 'cancel', 'return'];
  if (lowerKeywords.some(k => nameLower.includes(k))) {
    isLowerBetter = true;
  }

  return { target, isLowerBetter };
}

function getTargetStatusClass(actual, target, isLowerBetter) {
  if (actual === null || target === null || target === 0) return '';

  if (isLowerBetter) {
    // At or below target = green, up to 15% over = yellow, else red
    const ratio = actual / target;
    if (ratio <= 1.0) return 'green';
    if (ratio <= 1.15) return 'yellow';
    return 'red';
  } else {
    // Higher is better: â‰¥95% of target = green, â‰¥85% = yellow, else red
    const pct = (actual / target) * 100;
    if (pct >= 95) return 'green';
    if (pct >= 85) return 'yellow';
    return 'red';
  }
}

function fmtDeptVal(v) {
  if (v === null || v === undefined) return 'â€”';
  if (Math.abs(v) >= 1000) return '$' + (v / 1000).toFixed(1) + 'K';
  if (Number.isInteger(v)) return v.toLocaleString();
  return v % 1 === 0 ? v.toLocaleString() : v.toFixed(1);
}

function renderDept() {
  const allMetrics = deptSections.flatMap(s => s.metrics);
  if (allMetrics.length === 0) {
    document.getElementById('app').innerHTML = `
      <div class="error-screen">
        <h2>No department data found</h2>
        <p>Could not parse data from the Dept S.cards sheet.</p>
      </div>`;
    return;
  }

  let html = '';

  // Legend
  html += `<div class="legend">
    <span class="legend-item"><span class="legend-dot" style="background:#059669"></span> â‰¥ 95%</span>
    <span class="legend-item"><span class="legend-dot" style="background:#d97706"></span> 85â€“94%</span>
    <span class="legend-item"><span class="legend-dot" style="background:#dc2626"></span> &lt; 85%</span>
  </div>`;

  // KPI Cards â€” only these 4 metrics, in order (search all metrics, not just triplets)
  const triplets = allMetrics.filter(m => m.type === 'triplet');
  const topBoxKeys = [
    { key: 'aov', exclude: 'repeat' },  // NC $ AOV (not repeat)
    { key: 'cac' },                       // CAC
    { key: 'ctr' },                       // Meta CTR
    { key: 'repeat' },                    // Repeat Net $ AOV
  ];
  const topBoxMetrics = topBoxKeys.map(({ key, exclude }) => {
    // Prefer triplet metrics (have forecast/actual/plan data)
    return allMetrics.find(m => {
      const n = m.name.toLowerCase();
      return m.type === 'triplet' && n.includes(key) && (!exclude || !n.includes(exclude));
    }) || allMetrics.find(m => {
      const n = m.name.toLowerCase();
      return n.includes(key) && (!exclude || !n.includes(exclude));
    });
  }).filter(Boolean);

  if (topBoxMetrics.length > 0) {
    html += '<div class="kpi-grid">';
    topBoxMetrics.forEach(m => {
      const isTriplet = m.type === 'triplet';
      let val, status, fcast, pctLabel;

      if (isTriplet) {
        const fmtVal = (v) => {
          if (v === null || v === undefined) return 'â€”';
          if (m.isCurrency) {
            const abs = Math.abs(v);
            const sign = v < 0 ? '-' : '';
            if (abs >= 1000) return sign + '$' + (abs / 1000).toFixed(1) + 'K';
            return sign + '$' + Math.round(abs);
          }
          return fmtDeptVal(v);
        };
        val = fmtVal(m.actualTotal);
        fcast = fmtVal(m.forecastTotal);
        // Compute pva from actuals/forecast if pvaTotal is missing
        const pva = m.pvaTotal !== null ? m.pvaTotal :
          (m.actualTotal !== null && m.forecastTotal ? (m.actualTotal / m.forecastTotal) * 100 : null);
        status = getStatusClass(pva, m.isLowerBetter);
        pctLabel = fmtPct(pva);
      } else {
        // Standalone: get latest weekly value and compute status vs parsed target
        let latestVal = null;
        for (let k = m.weekly.length - 1; k >= 0; k--) {
          if (m.weekly[k] !== null) { latestVal = m.weekly[k]; break; }
        }
        val = latestVal !== null ? fmtDeptVal(latestVal) : (m.total !== null ? fmtDeptVal(m.total) : 'â€”');
        const targetNum = m.parsedTarget !== undefined ? m.parsedTarget : (m.targetMatch ? parseFloat(m.targetMatch) : null);
        const actualForPct = latestVal !== null ? latestVal : m.total;
        status = (actualForPct !== null && targetNum !== null)
          ? getTargetStatusClass(actualForPct, targetNum, m.isLowerBetter)
          : '';
        const pct = (actualForPct !== null && targetNum) ? (actualForPct / targetNum) * 100 : null;
        fcast = targetNum !== null ? fmtDeptVal(targetNum) + (m.name.includes('%') ? '%' : '') : null;
        pctLabel = fmtPct(pct);
      }

      html += `
        <div class="kpi-card">
          <div class="kpi-label">
            <span class="dept-badge">${m.dept}</span>${m.flag ? m.flag + ' ' : ''}${m.name}
          </div>
          <div class="kpi-value">${val}</div>
          ${isTriplet
            ? `<div class="kpi-forecast">of ${fcast} forecast</div>
               <span class="kpi-badge status-${status}">
                 <span class="kpi-dot"></span>
                 ${pctLabel} of plan
               </span>`
            : `${fcast ? `<div class="kpi-forecast">target ${fcast}</div>` : ''}
               ${status ? `<span class="kpi-badge status-${status}">
                 <span class="kpi-dot"></span>
                 ${pctLabel} of target
               </span>` : ''}`
          }
        </div>`;
    });
    html += '</div>';
  }

  // Charts for triplets â€” use CAC metric for actuals bar chart
  const cacMetric = triplets.find(m => m.name.toLowerCase().includes('cac')) || triplets[0];
  if (triplets.length > 0) {
    html += `<div class="charts-grid">
      <div class="chart-card">
        <div class="chart-title">CAC ðŸ‡ºðŸ‡² Actuals USD</div>
        <div class="chart-container"><canvas id="deptBarChart"></canvas></div>
      </div>
      <div class="chart-card">
        <div class="chart-title">Weekly Performance (95% Target)</div>
        <div class="chart-container"><canvas id="deptLineChart"></canvas></div>
      </div>
    </div>`;
  }

  // Sections as tables
  deptSections.forEach(section => {
    const sectionSlug = section.title.toLowerCase().replace(/\s+/g, '-');
    html += `<div class="table-card section-${sectionSlug}">
      <div class="table-header">${section.title}</div>
      <div class="table-wrapper"><table>
        <thead><tr>
          <th>Dept</th><th>Metric</th><th>Type</th>`;
    deptWeekLabels.forEach(w => { html += `<th>${w}</th>`; });
    html += `<th>Total</th></tr></thead><tbody>`;

    section.metrics.forEach(m => {
      if (m.type === 'triplet') {
        html += `<tr>
          <td class="metric-group-label" rowspan="3">${m.dept}</td>
          <td class="metric-group-label" rowspan="3">${m.flag ? m.flag + ' ' : ''}${m.name}</td>
          <td class="row-type">Forecast</td>`;
        m.forecastWeekly.forEach(v => {
          html += `<td>${v !== null ? fmtDeptVal(v) : ''}</td>`;
        });
        html += `<td><strong>${m.forecastTotal !== null ? fmtDeptVal(m.forecastTotal) : ''}</strong></td></tr>`;

        html += `<tr><td class="row-type">Actual</td>`;
        m.actualWeekly.forEach(v => {
          html += `<td>${v !== null ? fmtDeptVal(v) : ''}</td>`;
        });
        html += `<td><strong>${m.actualTotal !== null ? fmtDeptVal(m.actualTotal) : ''}</strong></td></tr>`;

        html += `<tr><td class="row-type">% of Plan</td>`;
        m.pvaWeekly.forEach(v => {
          const cls = v !== null && v !== 0 ? 'cell-' + getStatusClass(v, m.isLowerBetter) : '';
          html += `<td class="${cls}">${v !== null && v !== 0 ? fmtPct(v) : ''}</td>`;
        });
        const totalCls = m.pvaTotal !== null ? 'cell-' + getStatusClass(m.pvaTotal, m.isLowerBetter) : '';
        html += `<td class="${totalCls}"><strong>${fmtPct(m.pvaTotal)}</strong></td></tr>`;
      } else {
        // Standalone â€” color-code cells based on target
        html += `<tr>
          <td class="metric-group-label">${m.dept}</td>
          <td class="metric-group-label">${m.flag ? m.flag + ' ' : ''}${m.name}</td>
          <td class="row-type">Actual</td>`;
        m.weekly.forEach(v => {
          const cls = (v !== null && m.parsedTarget !== null)
            ? 'cell-' + getTargetStatusClass(v, m.parsedTarget, m.isLowerBetter)
            : '';
          html += `<td class="${cls}">${v !== null ? fmtDeptVal(v) : ''}</td>`;
        });
        const totalCls = (m.total !== null && m.parsedTarget !== null)
          ? 'cell-' + getTargetStatusClass(m.total, m.parsedTarget, m.isLowerBetter)
          : '';
        html += `<td class="${totalCls}"><strong>${m.total !== null ? fmtDeptVal(m.total) : ''}</strong></td></tr>`;
      }
    });

    html += '</tbody></table></div></div>';
  });

  document.getElementById('app').innerHTML = html;

  // Draw charts
  if (triplets.length > 0) {
    const cacForChart = triplets.find(m => m.name.toLowerCase().includes('cac')) || triplets[0];
    drawDeptBarChart(cacForChart);
    drawDeptLineChart(triplets);
  }
}

function drawDeptBarChart(metric) {
  if (!metric) return;
  const ctx = document.getElementById('deptBarChart');
  if (!ctx) return;
  if (deptBarChart) deptBarChart.destroy();

  deptBarChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: deptWeekLabels.slice(0, metric.forecastWeekly.length),
      datasets: [
        {
          label: 'Plan',
          data: metric.forecastWeekly.map(v => v !== null ? Math.abs(v) : null),
          backgroundColor: '#94a3b8',
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.7,
        },
        {
          label: 'Actual',
          data: metric.actualWeekly.map(v => v !== null ? Math.abs(v) : null),
          backgroundColor: '#3b82f6',
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.7,
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 16, font: { size: 12 } } },
      },
      scales: {
        y: {
          beginAtZero: true,
          grid: { color: '#f3f4f6' },
          ticks: { font: { size: 11 } }
        },
        x: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

function drawDeptLineChart(metrics) {
  const ctx = document.getElementById('deptLineChart');
  if (!ctx) return;
  if (deptLineChart) deptLineChart.destroy();

  const datasets = metrics.filter(m => m.pvaWeekly.some(v => v !== null && v !== 0)).map((m, i) => ({
    label: m.name,
    data: m.pvaWeekly.map(v => (v !== null && v !== 0) ? v : null),
    borderColor: METRIC_COLORS[i % METRIC_COLORS.length],
    backgroundColor: 'transparent',
    borderWidth: 2.5,
    pointRadius: 3,
    pointHoverRadius: 5,
    tension: 0.3,
    spanGaps: false,
  }));

  datasets.push({
    label: '95% Target',
    data: deptWeekLabels.map(() => 95),
    borderColor: '#dc2626',
    borderDash: [6, 4],
    borderWidth: 1.5,
    pointRadius: 0,
    pointHoverRadius: 0,
  });

  deptLineChart = new Chart(ctx, {
    type: 'line',
    data: { labels: deptWeekLabels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 12, font: { size: 11 } } },
        tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + (ctx.parsed.y !== null ? ctx.parsed.y + '%' : 'â€”') } }
      },
      scales: {
        y: {
          min: 0,
          max: 200,
          grid: { color: '#f3f4f6' },
          ticks: { font: { size: 11 }, callback: v => v + '%' }
        },
        x: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

async function loadDeptData() {
  const btn = document.querySelector('.refresh-btn');
  if (btn) btn.classList.add('loading');

  try {
    const res = await fetch(DEPT_CSV_URL);
    if (!res.ok) throw new Error('Failed to fetch department sheet');
    const text = await res.text();
    const rows = parseCSV(text);
    extractDeptData(rows);

    const allMetrics = deptSections.flatMap(s => s.metrics);
    if (allMetrics.length === 0) {
      document.getElementById('app').innerHTML = `
        <div class="error-screen">
          <h2>No department metrics found</h2>
          <p>Could not parse data from the Dept S.cards sheet.</p>
        </div>`;
      return;
    }

    renderDept();

    const now = new Date();
    document.getElementById('lastUpdated').textContent =
      'Updated ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } catch (err) {
    document.getElementById('app').innerHTML = `
      <div class="error-screen">
        <h2>Couldn't load department data</h2>
        <p>Make sure the Google Sheet is shared as "Anyone with the link."</p>
        <p style="margin-top:8px;font-size:12px;color:#6b7280;">${err.message}</p>
      </div>`;
  } finally {
    if (btn) btn.classList.remove('loading');
  }
}

// --- Rocks Tab ---
function extractRocksData(rows) {
  if (rows.length < 3) return;

  const weekRow = rows[1];
  rockWeekLabels = [];
  const dataCols = [];
  for (let j = 2; j <= 15 && j < weekRow.length; j++) {
    const val = (weekRow[j] || '').trim();
    if (val.match(/^WK\s*\d+/i)) {
      rockWeekLabels.push(val);
      dataCols.push(j);
    }
  }

  const totalCol = dataCols.length > 0 ? dataCols[dataCols.length - 1] + 1 : 16;

  rocksData = [];
  rockMilestoneDescriptions = {};
  const dataRows = rows.slice(2);

  for (let i = 0; i < dataRows.length; i++) {
    const row = dataRows[i];
    if (!row || row.length < 3) continue;

    const col0 = (row[0] || '').trim();
    const col1 = (row[1] || '').trim();
    const col1Lower = col1.toLowerCase();

    // Detect triplet: Forecast row
    if (col1Lower === 'forecast') {
      const forecastWeekly = dataCols.map(c => cleanNum(row[c]));
      const forecastSummary = cleanNum(row[totalCol]);

      const actualsRow = dataRows[i + 1];
      if (!actualsRow) { i += 2; continue; }

      const owner = (actualsRow[0] || '').trim();
      const description = (actualsRow[1] || '').trim();
      const actualWeekly = dataCols.map(c => cleanNum(actualsRow[c]));
      const actualSummary = cleanNum(actualsRow[totalCol]);

      const pvaRow = dataRows[i + 2];
      let pvaWeekly = dataCols.map(() => null);
      let pvaSummary = null;
      if (pvaRow && (pvaRow[1] || '').toLowerCase().includes('plan vs actual')) {
        pvaWeekly = dataCols.map(c => cleanNum(pvaRow[c]));
        pvaSummary = cleanNum(pvaRow[totalCol]);
      }

      // Find latest week with actual data
      let latestWeekIdx = -1;
      for (let k = actualWeekly.length - 1; k >= 0; k--) {
        if (actualWeekly[k] !== null) { latestWeekIdx = k; break; }
      }

      const currentMilestone = latestWeekIdx >= 0 ? (actualWeekly[latestWeekIdx] || 0) : 0;
      const expectedMilestone = latestWeekIdx >= 0 ? (forecastWeekly[latestWeekIdx] || 0) : 0;

      let rockStatus;
      if (pvaSummary !== null) {
        if (pvaSummary >= 100) rockStatus = 'on-track';
        else if (pvaSummary >= 50) rockStatus = 'at-risk';
        else rockStatus = 'off-track';
      } else {
        if (currentMilestone >= expectedMilestone) rockStatus = 'on-track';
        else if (currentMilestone >= expectedMilestone - 1) rockStatus = 'at-risk';
        else rockStatus = 'off-track';
      }

      if (owner && description) {
        rocksData.push({
          owner, description,
          forecastWeekly, forecastSummary,
          actualWeekly, actualSummary,
          pvaWeekly, pvaSummary,
          latestWeekIdx, currentMilestone, expectedMilestone, rockStatus,
        });
      }

      i += 2;
      continue;
    }

    // Detect milestone description rows
    if (col1.match(/^\s*Milestone\s*\d/i)) {
      const match = col1.match(/Milestone\s*(\d)/i);
      if (match && rocksData.length > 0) {
        const lastRock = rocksData[rocksData.length - 1];
        if (!rockMilestoneDescriptions[lastRock.owner]) {
          rockMilestoneDescriptions[lastRock.owner] = {};
        }
        rockMilestoneDescriptions[lastRock.owner][parseInt(match[1])] = col1.trim();
      }
    }
  }
}

function renderRocks() {
  if (rocksData.length === 0) {
    document.getElementById('app').innerHTML = `
      <div class="error-screen">
        <h2>No rocks data found</h2>
        <p>Could not parse data from the Rocks sheet.</p>
      </div>`;
    return;
  }

  let html = '';

  // Legend
  html += `<div class="legend">
    <span class="legend-item"><span class="legend-dot" style="background:#059669"></span> On Track (100%)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#d97706"></span> At Risk (50â€“99%)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#dc2626"></span> Off Track (&lt;50%)</span>
  </div>`;

  // KPI Cards
  const onTrackCount = rocksData.filter(r => r.rockStatus === 'on-track').length;
  const offTrackCount = rocksData.filter(r => r.rockStatus === 'off-track').length;
  const atRiskCount = rocksData.filter(r => r.rockStatus === 'at-risk').length;
  const totalRocks = rocksData.length;
  const onTrackPct = totalRocks > 0 ? Math.round((onTrackCount / totalRocks) * 100) : 0;
  const avgCompletion = rocksData.length > 0
    ? Math.round(rocksData.reduce((sum, r) => sum + (r.pvaSummary || 0), 0) / rocksData.length)
    : 0;

  const maxWeekIdx = Math.max(...rocksData.map(r => r.latestWeekIdx).filter(v => v >= 0), 0);
  const currentWeek = maxWeekIdx + 1;
  const totalWeeks = rockWeekLabels.length;

  const onTrackStatus = onTrackPct >= 80 ? 'green' : onTrackPct >= 60 ? 'yellow' : 'red';
  const avgStatus = avgCompletion >= 95 ? 'green' : avgCompletion >= 75 ? 'yellow' : 'red';
  const atRiskStatus = offTrackCount === 0 ? 'green' : offTrackCount <= 1 ? 'yellow' : 'red';

  html += '<div class="kpi-grid">';
  html += `
    <div class="kpi-card">
      <div class="kpi-label">ROCKS ON TRACK</div>
      <div class="kpi-value">${onTrackCount}/${totalRocks}</div>
      <div class="kpi-forecast">${offTrackCount} off track, ${atRiskCount} at risk</div>
      <span class="kpi-badge status-${onTrackStatus}">
        <span class="kpi-dot"></span>
        ${onTrackPct}% on track
      </span>
    </div>`;
  html += `
    <div class="kpi-card">
      <div class="kpi-label">AVERAGE COMPLETION</div>
      <div class="kpi-value">${avgCompletion}%</div>
      <div class="kpi-forecast">across all rocks</div>
      <span class="kpi-badge status-${avgStatus}">
        <span class="kpi-dot"></span>
        ${avgStatus === 'green' ? 'Healthy' : avgStatus === 'yellow' ? 'Monitor' : 'Behind'}
      </span>
    </div>`;
  html += `
    <div class="kpi-card">
      <div class="kpi-label">ROCKS OFF TRACK</div>
      <div class="kpi-value">${offTrackCount}</div>
      <div class="kpi-forecast">${atRiskCount} at risk</div>
      <span class="kpi-badge status-${atRiskStatus}">
        <span class="kpi-dot"></span>
        ${offTrackCount === 0 ? 'All clear' : offTrackCount + ' need attention'}
      </span>
    </div>`;
  html += `
    <div class="kpi-card">
      <div class="kpi-label">QUARTER PROGRESS</div>
      <div class="kpi-value">WK ${currentWeek}</div>
      <div class="kpi-forecast">of ${totalWeeks} weeks</div>
      <span class="kpi-badge" style="background:#e0e7ff;color:#3730a3;">
        <span class="kpi-dot" style="background:#3730a3;"></span>
        ${Math.round((currentWeek / totalWeeks) * 100)}% elapsed
      </span>
    </div>`;
  html += '</div>';

  // Rock Status Cards
  html += '<div class="rocks-grid">';
  rocksData.forEach(r => {
    const statusClass = 'rock-' + r.rockStatus;
    const statusLabel = r.rockStatus === 'on-track' ? 'On Track'
      : r.rockStatus === 'at-risk' ? 'At Risk' : 'Off Track';
    const badgeClass = r.rockStatus === 'on-track' ? 'status-green'
      : r.rockStatus === 'at-risk' ? 'status-yellow' : 'status-red';

    let milestoneBarHtml = '<div class="milestone-bar">';
    for (let m = 1; m <= 5; m++) {
      let segClass = '';
      if (m <= r.currentMilestone) segClass = 'ms-completed';
      else if (m <= r.expectedMilestone && m > r.currentMilestone) segClass = 'ms-behind';
      milestoneBarHtml += `<div class="milestone-segment ${segClass}"></div>`;
    }
    milestoneBarHtml += '</div>';

    const statusColor = r.rockStatus === 'on-track' ? '#059669' : r.rockStatus === 'at-risk' ? '#d97706' : '#dc2626';

    html += `
      <div class="rock-card ${statusClass}">
        <div class="rock-header">
          <span><span class="dept-badge">${r.owner}</span></span>
          <span class="kpi-badge ${badgeClass}" style="font-size:12px;">
            <span class="kpi-dot"></span>
            ${statusLabel}
          </span>
        </div>
        <div class="rock-description">${r.description}</div>
        ${milestoneBarHtml}
        <div class="milestone-labels">
          <span>M1</span><span>M2</span><span>M3</span><span>M4</span><span>M5</span>
        </div>
        <div class="rock-pva" style="color:${statusColor}">
          Milestone ${r.currentMilestone}/5 ${r.pvaSummary !== null ? '(' + Math.round(r.pvaSummary) + '%)' : ''}
        </div>
      </div>`;
  });
  html += '</div>';

  // Charts
  html += `<div class="charts-grid">
    <div class="chart-card">
      <div class="chart-title">Rock Milestone Progress â€” Expected vs Actual</div>
      <div class="chart-container"><canvas id="rockBarChart"></canvas></div>
    </div>
    <div class="chart-card">
      <div class="chart-title">Weekly Milestone Trajectory</div>
      <div class="chart-container"><canvas id="rockLineChart"></canvas></div>
    </div>
  </div>`;

  // Weekly Breakdown Table
  html += `<div class="table-card section-rocks">
    <div class="table-header">Weekly Milestone Breakdown</div>
    <div class="table-wrapper"><table>
      <thead><tr>
        <th>Owner</th><th>Rock</th><th>Type</th>`;
  rockWeekLabels.forEach(w => { html += `<th>${w}</th>`; });
  html += `<th>Status</th></tr></thead><tbody>`;

  rocksData.forEach(r => {
    // Forecast row
    html += `<tr>
      <td class="metric-group-label" rowspan="3">${r.owner}</td>
      <td class="metric-group-label" rowspan="3" style="max-width:200px;white-space:normal;font-size:12px;">
              <span>${r.description.length > 20 ? r.description.substring(0, 20) + '...' : r.description}</span>
              ${r.description.length > 20 ? `<span style="display:none;">${r.description}</span>
              <button onclick="const td=this.parentElement;const spans=td.querySelectorAll('span');spans[0].style.display=spans[0].style.display==='none'?'':'none';spans[1].style.display=spans[1].style.display==='none'?'':'none';this.textContent=this.textContent==='more'?'less':'more';" style="background:none;border:none;color:#3b82f6;cursor:pointer;font-size:11px;padding:0 4px;">more</button>` : ''}
            </td>
      <td class="row-type">Forecast</td>`;
    r.forecastWeekly.forEach(v => {
      html += `<td>${v !== null ? v : ''}</td>`;
    });
    html += `<td><strong>${r.forecastSummary !== null ? r.forecastSummary : ''}</strong></td></tr>`;

    // Actuals row
    html += `<tr><td class="row-type">Actual</td>`;
    r.actualWeekly.forEach((v, idx) => {
      let cls = '';
      if (v !== null && r.forecastWeekly[idx] !== null) {
        cls = v >= r.forecastWeekly[idx] ? 'cell-green' : 'cell-red';
      }
      html += `<td class="${cls}">${v !== null ? v : ''}</td>`;
    });
    html += `<td><strong>${r.actualSummary !== null ? r.actualSummary : ''}</strong></td></tr>`;

    // PvA row
    html += `<tr><td class="row-type">% of Plan</td>`;
    r.pvaWeekly.forEach(v => {
      const cls = v !== null && v !== 0 ? 'cell-' + getStatusClass(v) : '';
      html += `<td class="${cls}">${v !== null && v !== 0 ? fmtPct(v) : ''}</td>`;
    });
    const totalCls = r.pvaSummary !== null ? 'cell-' + getStatusClass(r.pvaSummary) : '';
    html += `<td class="${totalCls}"><strong>${r.pvaSummary !== null ? fmtPct(r.pvaSummary) : ''}</strong></td></tr>`;
  });

  html += '</tbody></table></div></div>';


  document.getElementById('app').innerHTML = html;

  drawRockBarChart();
  drawRockLineChart();
}

const ROCK_COLORS = ['#3b82f6', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#06b6d4'];

function drawRockBarChart() {
  const ctx = document.getElementById('rockBarChart');
  if (!ctx) return;
  if (rockBarChart) rockBarChart.destroy();

  const labels = rocksData.map(r => r.owner);
  const expectedData = rocksData.map(r => r.expectedMilestone);
  const actualData = rocksData.map(r => r.currentMilestone);
  const barColors = rocksData.map(r => {
    if (r.rockStatus === 'on-track') return '#059669';
    if (r.rockStatus === 'at-risk') return '#d97706';
    return '#dc2626';
  });

  rockBarChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        {
          label: 'Expected Milestone',
          data: expectedData,
          backgroundColor: '#94a3b8',
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.7,
        },
        {
          label: 'Actual Milestone',
          data: actualData,
          backgroundColor: barColors,
          borderRadius: 4,
          barPercentage: 0.8,
          categoryPercentage: 0.7,
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 16, font: { size: 12 } } },
        tooltip: {
          callbacks: {
            afterLabel: (ctx) => {
              if (ctx.datasetIndex === 1) {
                const rock = rocksData[ctx.dataIndex];
                return rock.description.substring(0, 50) + (rock.description.length > 50 ? '...' : '');
              }
              return '';
            }
          }
        }
      },
      scales: {
        y: {
          min: 0,
          max: 5,
          grid: { color: '#f3f4f6' },
          ticks: { stepSize: 1, font: { size: 11 }, callback: v => 'M' + v }
        },
        x: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

function drawRockLineChart() {
  const ctx = document.getElementById('rockLineChart');
  if (!ctx) return;
  if (rockLineChart) rockLineChart.destroy();

  const datasets = rocksData.map((r, i) => ({
    label: r.owner,
    data: r.actualWeekly.map(v => v),
    borderColor: ROCK_COLORS[i % ROCK_COLORS.length],
    backgroundColor: 'transparent',
    borderWidth: 2.5,
    pointRadius: 3,
    pointHoverRadius: 5,
    tension: 0.3,
    spanGaps: false,
  }));

  // Average forecast reference line
  if (rocksData.length > 0) {
    const avgForecast = rockWeekLabels.map((_, wk) => {
      const vals = rocksData.map(r => r.forecastWeekly[wk]).filter(v => v !== null);
      return vals.length > 0 ? vals.reduce((a, b) => a + b, 0) / vals.length : null;
    });
    datasets.push({
      label: 'Avg Forecast',
      data: avgForecast,
      borderColor: '#dc2626',
      borderDash: [6, 4],
      borderWidth: 1.5,
      pointRadius: 0,
      pointHoverRadius: 0,
    });
  }

  rockLineChart = new Chart(ctx, {
    type: 'line',
    data: { labels: rockWeekLabels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: 'bottom', labels: { usePointStyle: true, padding: 12, font: { size: 11 } } },
        tooltip: {
          callbacks: {
            label: ctx => ctx.dataset.label + ': Milestone ' + (ctx.parsed.y !== null ? ctx.parsed.y : 'â€”')
          }
        }
      },
      scales: {
        y: {
          min: 0,
          max: 5,
          grid: { color: '#f3f4f6' },
          ticks: { stepSize: 1, font: { size: 11 }, callback: v => 'M' + v }
        },
        x: { grid: { display: false }, ticks: { font: { size: 11 } } }
      }
    }
  });
}

async function loadRocksData() {
  const btn = document.querySelector('.refresh-btn');
  if (btn) btn.classList.add('loading');

  try {
    const res = await fetch(ROCKS_CSV_URL);
    if (!res.ok) throw new Error('Failed to fetch rocks sheet');
    const text = await res.text();
    const rows = parseCSV(text);
    extractRocksData(rows);

    if (rocksData.length === 0) {
      document.getElementById('app').innerHTML = `
        <div class="error-screen">
          <h2>No rocks found</h2>
          <p>Could not parse rock data from the spreadsheet.</p>
        </div>`;
      return;
    }

    renderRocks();

    const now = new Date();
    document.getElementById('lastUpdated').textContent =
      'Updated ' + now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  } catch (err) {
    document.getElementById('app').innerHTML = `
      <div class="error-screen">
        <h2>Couldn't load rocks data</h2>
        <p>Make sure the Google Sheet is shared as "Anyone with the link."</p>
        <p style="margin-top:8px;font-size:12px;color:#6b7280;">${err.message}</p>
      </div>`;
  } finally {
    if (btn) btn.classList.remove('loading');
  }
}

// --- Password gate for Rocks ---
const ROCKS_PW_HASH = '88ad931483ff2d28191c8119d9a7669feb286abae3bc9be00a4ea1cf7e80b939';

async function hashPassword(pw) {
  const data = new TextEncoder().encode(pw);
  const buf = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function checkRocksPassword() {
  const input = document.getElementById('pwInput');
  const hash = await hashPassword(input.value);
  if (hash === ROCKS_PW_HASH) {
    sessionStorage.setItem('rocksUnlocked', '1');
    document.getElementById('pwOverlay').style.display = 'none';
    input.value = '';
    document.getElementById('pwError').style.display = 'none';
    switchTab('rocks');
  } else {
    document.getElementById('pwError').style.display = 'block';
    input.value = '';
    input.focus();
  }
}

// --- Tab switching ---
function switchTab(tab) {
  // Password gate for Rocks tab
  if (tab === 'rocks' && sessionStorage.getItem('rocksUnlocked') !== '1') {
    document.getElementById('pwOverlay').style.display = 'flex';
    document.getElementById('pwInput').focus();
    return;
  }

  currentTab = tab;
  document.querySelectorAll('.nav-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.tab === tab);
  });

  // Update header title
  const titles = {
    company: 'Q1 2026 Company Scorecard',
    department: 'Q1 2026 Department Scorecard',
    rocks: 'Q1 2026 Rocks',
  };
  document.querySelector('.header h1').textContent = titles[tab] || titles.company;

  // Show/hide market toggle (department and rocks views are global)
  const toggle = document.querySelector('.toggle-group');
  if (tab === 'department' || tab === 'rocks') {
    toggle.style.display = 'none';
  } else {
    toggle.style.display = 'flex';
  }

  document.getElementById('app').innerHTML = `
    <div class="loading-screen">
      <div class="spinner"></div>
      <div class="loading-text">Loading scorecard...</div>
    </div>`;

  if (tab === 'company') {
    loadData();
  } else if (tab === 'department') {
    loadDeptData();
  } else if (tab === 'rocks') {
    loadRocksData();
  }
}

loadData();
setInterval(() => {
  if (currentTab === 'company') loadData();
  else if (currentTab === 'department') loadDeptData();
  else if (currentTab === 'rocks') loadRocksData();
}, 5 * 60 * 1000);
</script>
</body>
</html>
